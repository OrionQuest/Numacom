Machine Numbers
---------------

This is an abbreviation for binary floating-point numbers, which is how real
numbers are stored on modern digital computers. In scientific notation,
:math:`x=\pm a\times 2^b`, where :math:`a` is called the *mantissa* and :math:`b` the *exponent*.
We also follow the convention that :math:`1\leq a<2`; the idea being that for
any number :math:`x`, we can always divide it by an appropriate power of
:math:`2`, such that the result will be within :math:`[1,2)`. For example:

.. math::
    x = 5_{(10)} = 1.25_{(10)}\times 2^2 = 1.01_{(2)}\times 2^2

Thus, a machine number is stored as:

.. math::
    x=\pm 1.a_1 a_2\ldots a_{k-1}a_k\times 2^b

* In *single precision* we store :math:`k=23` binary digits, and the exponent
  :math:`b` ranges between :math:`-126\leq b\leq 127`. The largest number we can
  thus represent is :math:`(2-2^{-23})\times 2^{127}\approx 3.4\times 10^{38}`.
* In *double precision* we store :math:`k=52` binary digits, and the exponent
  :math:`b` ranges between :math:`-1022\leq b\leq 1023`. The largest number we
  can thus represent is :math:`(2-2^{-52})\times 2^{1023}\approx 1.8\times 10^{308}`.

In other words, single precision provides :math:`23` binary significant digits.
In order to translate it to familiar decimal terms we note that
:math:`2^{10}\approx 10^3`, thus, :math:`10` binary significant digits are roughly
equivalent to :math:`3` decimal significant digits. Using this, we can say that
single precision provides approximately :math:`7` decimal significant digits,
while double precision offers slightly more than :math:`15`.

Absolute and Relative Error
---------------------------

As we saw before, all computations on a computer are approximate by nature, due
to the limited precision available. As a consequence, some amount of *error* has
to be tolerated in all computation. In order to better understand these errors,
the absolute and relative error measures are used. Let :math:`q` denote the
exact (analytic) quantity that we expect out of a computation, and let
:math:`\hat q` denote the (likely compromised) value actually generated by the
computer.

The *absolute error* is :math:`e=\vert q - \hat q\vert`. This is useful for
framing the result within a certain interval, since :math:`e\leq\delta` implies
:math:`q\in[\hat q-\delta,\hat q + \delta]`. The *relative error* is
:math:`e=\vert q - \hat q\vert / \vert q\vert`. The result may be expressed as a
percentile and is useful for assessing the error relative to the value of the
exact quantity. For example, an absolute error of :math:`10^{-3}` may be
insignificant when the intended value of :math:`q` is in the order of
:math:`10^6`, but would be very severe if :math:`q\approx 10^{-2}`.

Rounding and Truncation
-----------------------

When storing a number on the computer, if the number happens to contain more
digits than it is possible to represent via a machine number, an approximation
is made via *rounding* or *truncation*. When using truncated results, the
machine number is constructed by simply discarding significant digits that
cannot be stored; rounding approximates a quantity with the *closest*
machine-precision number. For example, when approximating
:math:`\pi=3.1415926535\ldots` to :math:`5` decimal significant digits,
truncation would give :math:`\pi\approx 3.1415` while the rounded result would
be :math:`\pi\approx 3.1416`. Rounding and truncation are similarly defined for
binary numbers. For example, :math:`0.1011011101110\ldots_{(2)}` would be
approximated to :math:`5` binary significant digits as :math:`x\approx
0.10110_{(2)}` using truncation, and :math:`x\approx 0.10111_{(2)}` when
rounded.

`Python <https://www.python.org/>`_ has a built-in function ``round`` for
rounding decimal numbers, as shown below: ::

    >>> from math import pi
    >>> pi
    3.141592653589793
    >>> round(pi,3)
    3.142
    >>> round(pi,5)
    3.14159

There are no built-in functions for truncating a number. However, the following
``truncate`` function can be readily defined and allows us to truncate numbers similar to the
``round`` function shown above. ::

    >>> import math
    >>> def truncate(number,digits):
    ...     stepper=pow(10.0,digits)
    ...     return math.trunc(stepper*number)/stepper
    ...
    >>> truncate(pi,3)
    3.141
    >>> truncate(pi,5)
    3.14159
